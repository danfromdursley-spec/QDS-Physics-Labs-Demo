<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>QDS Number Coherence Lab v1</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#0f1620; --panel2:#0c121a; --ink:#e8eef7; --muted:#9bb0c7;
    --line:#223246; --accent:#7dd3fc; --good:#86efac; --warn:#fbbf24; --bad:#fb7185;
    --radius:18px; --shadow:0 12px 40px rgba(0,0,0,.45);
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }
  *{box-sizing:border-box}
  body{
    margin:0; color:var(--ink); background:radial-gradient(1200px 600px at 20% -10%, rgba(125,211,252,.12), transparent 60%),
                                 radial-gradient(900px 500px at 120% 0%, rgba(134,239,172,.08), transparent 55%),
                                 linear-gradient(180deg, #070a0f, var(--bg));
    font-family:var(--sans);
  }
  header{
    position:sticky; top:0; z-index:9;
    backdrop-filter: blur(10px);
    background: rgba(11,15,20,.72);
    border-bottom:1px solid rgba(34,50,70,.55);
  }
  .wrap{max-width:1050px; margin:0 auto; padding:14px 14px 22px}
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
  .brand{
    display:flex; gap:10px; align-items:center; justify-content:space-between;
  }
  .title{display:flex; flex-direction:column; gap:2px}
  h1{font-size:16px; margin:0; letter-spacing:.3px}
  .sub{font-size:12px; color:var(--muted)}
  .badge{
    font-size:12px; padding:6px 10px; border:1px solid rgba(125,211,252,.35);
    border-radius:999px; color:var(--accent); background:rgba(125,211,252,.08);
    font-family:var(--mono)
  }
  .pill{
    font-size:12px; padding:6px 10px; border:1px solid rgba(34,50,70,.8);
    border-radius:999px; color:var(--muted); background:rgba(15,22,32,.55);
    font-family:var(--mono)
  }
  .grid{display:grid; gap:12px}
  @media(min-width:860px){ .grid{grid-template-columns: 1.2fr .8fr} }
  .card{
    background:linear-gradient(180deg, rgba(15,22,32,.92), rgba(12,18,26,.88));
    border:1px solid rgba(34,50,70,.7);
    border-radius:var(--radius);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .card h2{font-size:13px; margin:0; letter-spacing:.35px}
  .card .hd{
    padding:12px 12px; border-bottom:1px solid rgba(34,50,70,.55);
    display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
    background:rgba(12,18,26,.4);
  }
  .card .bd{padding:12px}
  textarea,input,select{
    width:100%;
    background:rgba(6,10,14,.55);
    border:1px solid rgba(34,50,70,.75);
    color:var(--ink);
    border-radius:14px;
    padding:10px 10px;
    font-size:13px;
    outline:none;
  }
  textarea{min-height:118px; resize:vertical; font-family:var(--mono)}
  .btn{
    border:1px solid rgba(34,50,70,.85);
    background:rgba(15,22,32,.75);
    color:var(--ink);
    border-radius:14px;
    padding:10px 12px;
    font-size:13px;
    cursor:pointer;
    user-select:none;
  }
  .btn:hover{border-color:rgba(125,211,252,.45)}
  .btn.primary{
    border-color:rgba(125,211,252,.45);
    background:rgba(125,211,252,.12);
    color:var(--accent);
  }
  .btn.good{
    border-color:rgba(134,239,172,.4);
    background:rgba(134,239,172,.10);
    color:var(--good);
  }
  .btn.warn{
    border-color:rgba(251,191,36,.35);
    background:rgba(251,191,36,.10);
    color:var(--warn);
  }
  .btn.bad{
    border-color:rgba(251,113,133,.35);
    background:rgba(251,113,133,.10);
    color:var(--bad);
  }
  .kv{display:grid; grid-template-columns: 1fr; gap:10px}
  @media(min-width:860px){ .kv{grid-template-columns: 1fr 1fr} }
  .kbox{
    border:1px solid rgba(34,50,70,.65);
    border-radius:14px;
    padding:10px;
    background:rgba(6,10,14,.35);
  }
  .kbox .k{font-size:11px; color:var(--muted); font-family:var(--mono)}
  .kbox .v{font-size:14px; margin-top:4px; font-family:var(--mono)}
  .mini{font-size:12px; color:var(--muted); line-height:1.35}
  .hr{height:1px; background:rgba(34,50,70,.55); margin:12px 0}
  .tabs{display:flex; gap:8px; flex-wrap:wrap}
  .tab{padding:8px 10px; border-radius:999px; border:1px solid rgba(34,50,70,.75);
       background:rgba(12,18,26,.35); font-size:12px; color:var(--muted); cursor:pointer}
  .tab.on{border-color:rgba(125,211,252,.45); color:var(--accent); background:rgba(125,211,252,.10)}
  .hide{display:none}
  canvas{width:100%; height:180px; border-radius:14px; border:1px solid rgba(34,50,70,.65);
         background:rgba(6,10,14,.35)}
  .mono{font-family:var(--mono)}
  .log{
    max-height:260px; overflow:auto;
    border:1px solid rgba(34,50,70,.65);
    border-radius:14px;
    padding:10px;
    background:rgba(6,10,14,.35);
    font-family:var(--mono);
    font-size:12px;
    line-height:1.35;
    white-space:pre-wrap;
  }
  .tiny{font-size:11px; color:var(--muted)}
  .toggle{display:flex; gap:8px; align-items:center; font-size:12px; color:var(--muted); user-select:none}
  .toggle input{width:auto}
</style>
</head>
<body>
<header>
  <div class="wrap brand">
    <div class="title">
      <h1>QDS Number Coherence Lab <span class="badge">Mode: instrument</span></h1>
      <div class="sub">Kernel-weighted coherence in numeric strings • null-model sanity • optional Hebrew numeral seam miner</div>
    </div>
    <div class="row">
      <span class="pill">offline • no calls</span>
      <label class="toggle"><input id="lowFx" type="checkbox" /> Low-FX</label>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="card" style="margin-bottom:12px">
    <div class="hd">
      <h2>Reality check</h2>
      <span class="pill">QDS_PROTO_DISCLAIMER_V1</span>
    </div>
    <div class="bd mini">
      This is a <b>structure / coherence instrument</b> for exploring patterns in number strings (digits or chunks). It does <b>not</b> “decode truth” and it will happily generate meaningful-looking fragments by chance.
      Use the <b>Null model</b> panel to keep yourself honest.
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <div class="hd">
        <h2>Input</h2>
        <div class="tabs">
          <div class="tab on" data-tab="t_main">Main</div>
          <div class="tab" data-tab="t_hebrew">Hebrew seam lab</div>
          <div class="tab" data-tab="t_export">Export</div>
        </div>
      </div>
      <div class="bd">

        <div id="t_main">
          <div class="mini">Paste a number (or any text). For numeric modes we extract digits. For base-26 we parse as BigInt when possible.</div>
          <div style="height:8px"></div>
          <textarea id="numIn" spellcheck="false">150130937545296572356771972164254457814047970568738777235893533016064</textarea>

          <div style="height:10px"></div>

          <div class="row">
            <div style="flex:1 1 220px">
              <div class="tiny mono">Tokenization</div>
              <select id="tokenMode">
                <option value="digits">Digits (0–9)</option>
                <option value="pairs">Pairs (00–99)</option>
                <option value="triplets" selected>Triplets (000–999)</option>
                <option value="base26">Base-26 letters from whole integer (A=0..Z=25)</option>
              </select>
            </div>
            <div style="flex:1 1 220px">
              <div class="tiny mono">Max tokens (performance cap)</div>
              <input id="maxN" type="number" min="50" max="5000" value="1200" />
            </div>
          </div>

          <div style="height:10px"></div>

          <div class="row">
            <button class="btn primary" id="runBtn">Run analysis</button>
            <button class="btn" id="resetBtn">Reset</button>
            <button class="btn warn" id="nullBtn">Null model (shuffle)</button>
            <label class="toggle"><input id="mcOn" type="checkbox" /> Monte-Carlo (×50)</label>
          </div>

          <div class="hr"></div>

          <div class="kv" id="kvs">
            <div class="kbox"><div class="k">tokens</div><div class="v" id="kv_tokens">—</div></div>
            <div class="kbox"><div class="k">alphabet size (unique)</div><div class="v" id="kv_alpha">—</div></div>
            <div class="kbox"><div class="k">entropy H (bits/token)</div><div class="v" id="kv_H">—</div></div>
            <div class="kbox"><div class="k">transition entropy H₁</div><div class="v" id="kv_H1">—</div></div>
            <div class="kbox"><div class="k">ACF area (positive)</div><div class="v" id="kv_acfA">—</div></div>
            <div class="kbox"><div class="k">τ̂ (exp fit to ACF)</div><div class="v" id="kv_tauhat">—</div></div>
            <div class="kbox"><div class="k">QDS coherence score (0–1)</div><div class="v" id="kv_score">—</div></div>
            <div class="kbox"><div class="k">Δ score vs null (if run)</div><div class="v" id="kv_delta">—</div></div>
          </div>

          <div class="hr"></div>

          <div class="row">
            <div style="flex:1 1 360px">
              <div class="tiny mono">QDS kernel params (time-only)</div>
              <div class="mini">We treat token index as “time”. Kernel weight: <span class="mono">w(d)=exp(-d/τ)</span>. λ is unused in 1D mode (kept for future 2D symbol-space).</div>
              <div style="height:8px"></div>
              <div class="row">
                <div style="flex:1 1 120px">
                  <div class="tiny mono">τ (tokens)</div>
                  <input id="tau" type="number" min="1" max="5000" value="28" />
                </div>
                <div style="flex:1 1 120px">
                  <div class="tiny mono">σ² (scale)</div>
                  <input id="sig2" type="number" min="0.01" step="0.01" value="0.36" />
                </div>
                <div style="flex:1 1 120px">
                  <div class="tiny mono">max lag</div>
                  <input id="maxLag" type="number" min="10" max="300" value="90" />
                </div>
              </div>
            </div>
            <div style="flex:1 1 360px">
              <div class="tiny mono">Charts</div>
              <canvas id="acfCanvas" width="900" height="220"></canvas>
              <div class="tiny">ACF (autocorrelation) by lag • kernel fit overlay</div>
            </div>
          </div>

          <div class="hr"></div>

          <div class="tiny mono">Notes</div>
          <div class="mini">
            Score blends: low entropy + structured transitions + long correlation length. It’s a <b>coherence proxy</b>, not meaning.
            If Δ vs null stays near zero, you’re mostly seeing coincidence.
          </div>
        </div>

        <div id="t_hebrew" class="hide">
          <div class="mini">
            Hebrew numeral “spelling” for 3-digit groups (accuracy-first, additive hundreds/tens/ones). Then seam-scan for a small watchlist of word-shaped hits.
          </div>
          <div style="height:10px"></div>
          <div class="row">
            <button class="btn primary" id="hebRunBtn">Build Hebrew stream (from digits)</button>
            <label class="toggle"><input id="hebWatchOn" type="checkbox" checked/> Watchlist hits</label>
          </div>
          <div style="height:10px"></div>
          <div class="tiny mono">Hebrew blocks (3-digit groups)</div>
          <div class="log" id="hebBlocks">—</div>
          <div style="height:10px"></div>
          <div class="tiny mono">Seam hits (in order)</div>
          <div class="log" id="hebSeams">—</div>
          <div class="tiny">
            Watchlist (editable in code): מהר / את / סדר / עזר / רצו / שנו / שלח.
            This is just to reproduce the kind of seam-collision you noticed—run Null model above to see baseline.
          </div>
        </div>

        <div id="t_export" class="hide">
          <div class="mini">Export the latest run as JSON or TXT. Nothing leaves your device.</div>
          <div style="height:10px"></div>
          <div class="row">
            <button class="btn good" id="copyJsonBtn">Copy JSON</button>
            <button class="btn" id="dlJsonBtn">Download JSON</button>
            <button class="btn" id="dlTxtBtn">Download TXT</button>
          </div>
          <div style="height:10px"></div>
          <div class="tiny mono">Last result</div>
          <div class="log" id="outBox">Run analysis to populate…</div>
        </div>

      </div>
    </div>

    <div class="card">
      <div class="hd">
        <h2>Null model + run log</h2>
        <span class="pill mono" id="statusPill">ready</span>
      </div>
      <div class="bd">
        <div class="mini">
          Null model = shuffle tokens (frequency preserved, order destroyed). If your “meaning” survives null, we’re onto something;
          if it collapses, it was vibe-dust.
        </div>
        <div style="height:10px"></div>
        <div class="log" id="logBox"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const logBox = $("logBox");
  const statusPill = $("statusPill");
  const outBox = $("outBox");

  let last = null;      // last analysis result
  let lastNull = null;  // last null result

  function setStatus(s){ statusPill.textContent = s; }
  function log(msg){
    const ts = new Date().toISOString().slice(11,19);
    logBox.textContent += `[${ts}] ${msg}\n`;
    logBox.scrollTop = logBox.scrollHeight;
  }

  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
  function fmt(x, d=4){
    if (x === null || x === undefined || !isFinite(x)) return "—";
    const ax = Math.abs(x);
    if (ax !== 0 && (ax < 1e-3 || ax > 1e6)) return x.toExponential(3);
    return x.toFixed(d);
  }

  function digitsOnly(s){ return (s||"").replace(/\D+/g,""); }

  function tokenizeDigits(d, maxN){
    const arr = d.split("").slice(0,maxN).map(ch=>ch.charCodeAt(0)-48);
    return {tokens: arr, alpha: 10, kind:"digits"};
  }
  function tokenizeChunks(d, k, maxN){
    const n = Math.floor(d.length / k);
    const take = Math.min(n, maxN);
    const out = new Array(take);
    for(let i=0;i<take;i++){
      out[i] = parseInt(d.slice(i*k, i*k+k), 10);
    }
    const alpha = Math.pow(10,k);
    return {tokens: out, alpha, kind:`chunks${k}`};
  }

  function tokenizeBase26FromBigInt(d, maxN){
    // whole integer -> base26 digits -> map 0..25 to A..Z
    // Note: output tokens are 0..25 numbers (letters are for display)
    try{
      let x = BigInt(d);
      if (x < 0n) x = -x;
      if (x === 0n) return {tokens:[0], alpha:26, kind:"base26"};
      const out = [];
      const base = 26n;
      while(x > 0n && out.length < maxN){
        const r = Number(x % base);
        out.push(r);
        x = x / base;
      }
      out.reverse();
      return {tokens: out, alpha:26, kind:"base26"};
    }catch(e){
      return {tokens:[], alpha:26, kind:"base26", err:"BigInt parse failed"};
    }
  }

  function uniqueCount(arr){
    const s = new Set(arr);
    return s.size;
  }

  function shannonEntropyBits(arr){
    // H = -sum p log2 p
    const n = arr.length;
    if (!n) return 0;
    const m = new Map();
    for(const v of arr) m.set(v, (m.get(v)||0)+1);
    let H=0;
    for(const c of m.values()){
      const p = c/n;
      H -= p * Math.log2(p);
    }
    return H;
  }

  function transitionEntropyBits(arr){
    // conditional entropy of next given current; estimate from transitions
    const n = arr.length;
    if (n < 2) return 0;
    const out = new Map(); // key: a -> map of b counts
    const countsA = new Map();
    for(let i=0;i<n-1;i++){
      const a = arr[i], b = arr[i+1];
      countsA.set(a, (countsA.get(a)||0)+1);
      if(!out.has(a)) out.set(a, new Map());
      const mm = out.get(a);
      mm.set(b, (mm.get(b)||0)+1);
    }
    let H1=0;
    for(const [a, mm] of out.entries()){
      const ca = countsA.get(a);
      const pa = ca/(n-1);
      let Ha=0;
      for(const cb of mm.values()){
        const p = cb/ca;
        Ha -= p*Math.log2(p);
      }
      H1 += pa*Ha;
    }
    return H1;
  }

  function mean(arr){
    let s=0;
    for(const v of arr) s += v;
    return s/arr.length;
  }
  function variance(arr, mu){
    let s=0;
    for(const v of arr){
      const d=v-mu;
      s += d*d;
    }
    return s/arr.length;
  }

  function acf(arr, maxLag){
    // normalized autocorrelation for numeric tokens
    const n = arr.length;
    if (n < 3) return {lags:[], ac:[]};
    const mu = mean(arr);
    const v = variance(arr, mu);
    if (v === 0) return {lags:[0], ac:[1]};
    const L = clamp(maxLag, 1, Math.min(300, n-2));
    const ac = new Array(L+1);
    ac[0]=1;
    for(let lag=1; lag<=L; lag++){
      let s=0;
      const m = n-lag;
      for(let i=0;i<m;i++){
        s += (arr[i]-mu)*(arr[i+lag]-mu);
      }
      ac[lag] = (s/m)/v;
    }
    const lags = Array.from({length:L+1}, (_,i)=>i);
    return {lags, ac};
  }

  function positiveArea(ac){
    // sum of positive correlations excluding lag0
    let s=0;
    for(let i=1;i<ac.length;i++){
      if (ac[i] > 0) s += ac[i];
    }
    return s;
  }

  function fitExpTau(ac){
    // fit log(ac[lag]) ~ -lag/tau for positive ac values in early lags
    // use lags 1..L where ac>0 and reasonably above noise
    const xs=[], ys=[];
    const L = Math.min(ac.length-1, 80);
    for(let lag=1; lag<=L; lag++){
      const y = ac[lag];
      if (y > 0.02 && y < 0.999){
        xs.push(lag);
        ys.push(Math.log(y));
      }
    }
    if (xs.length < 4) return null;
    // linear regression y = a + b x ; b ~ -1/tau
    let sx=0, sy=0, sxx=0, sxy=0;
    for(let i=0;i<xs.length;i++){
      const x=xs[i], y=ys[i];
      sx += x; sy += y; sxx += x*x; sxy += x*y;
    }
    const n = xs.length;
    const denom = (n*sxx - sx*sx);
    if (denom === 0) return null;
    const b = (n*sxy - sx*sy) / denom;
    if (b >= 0) return null;
    return -1/b;
  }

  function qdsKernelWeights(maxLag, tau){
    const w = new Array(maxLag+1);
    w[0]=1;
    for(let d=1; d<=maxLag; d++) w[d] = Math.exp(-d / tau);
    return w;
  }

  function kernelWeightedACFArea(ac, tau){
    const L = ac.length-1;
    const w = qdsKernelWeights(L, tau);
    let s=0;
    for(let d=1; d<=L; d++){
      if (ac[d] > 0) s += w[d]*ac[d];
    }
    return s;
  }

  function coherenceScore(H, H1, acAreaW, alpha, maxLag){
    // Normalize:
    // H_norm vs log2(alpha); H1_norm vs log2(alpha)
    const Hmax = Math.log2(Math.max(2, alpha));
    const h = clamp(H / Hmax, 0, 1);
    const h1 = clamp(H1 / Hmax, 0, 1);

    // acAreaW max is roughly sum_{d=1..maxLag} exp(-d/tau) ~ tau (bounded)
    // normalize by min(maxLag, 60) to keep stable across settings
    const normDen = Math.max(8, Math.min(maxLag, 60));
    const a = clamp(acAreaW / normDen, 0, 1);

    // Score: low entropy + low transition entropy + high correlation
    const score = clamp(0.42*(1-h) + 0.28*(1-h1) + 0.30*(a), 0, 1);
    return {score, h, h1, a};
  }

  function drawACF(canvas, lags, ac, tauFit){
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    // axes
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(155,176,199,.35)";
    ctx.beginPath();
    ctx.moveTo(40, H-30);
    ctx.lineTo(W-10, H-30);
    ctx.moveTo(40, 10);
    ctx.lineTo(40, H-30);
    ctx.stroke();

    // zero line
    const y0 = mapY(0);
    ctx.strokeStyle = "rgba(155,176,199,.18)";
    ctx.beginPath();
    ctx.moveTo(40, y0); ctx.lineTo(W-10, y0);
    ctx.stroke();

    const L = lags.length ? lags[lags.length-1] : 1;
    function mapX(x){ return 40 + (W-55) * (x / Math.max(1,L)); }
    function mapY(y){ return 10 + (H-45) * (1 - (y + 1) / 2); } // y in [-1,1]

    // ACF line
    ctx.strokeStyle = "rgba(125,211,252,.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let i=0;i<lags.length;i++){
      const x = mapX(lags[i]);
      const y = mapY(clamp(ac[i], -1, 1));
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // exp fit overlay (if available)
    if (tauFit && isFinite(tauFit) && tauFit>0){
      ctx.strokeStyle = "rgba(134,239,172,.75)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<lags.length;i++){
        const d = lags[i];
        const yv = (d===0) ? 1 : Math.exp(-d/tauFit);
        const x = mapX(d);
        const y = mapY(yv);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    // labels
    ctx.fillStyle = "rgba(155,176,199,.85)";
    ctx.font = "12px " + getComputedStyle(document.documentElement).getPropertyValue('--mono');
    ctx.fillText("ACF", 44, 22);
    ctx.fillText("lag", W-42, H-12);
    ctx.save();
    ctx.translate(14, H/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText("corr", 0, 0);
    ctx.restore();
  }

  function shuffleCopy(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      const t=a[i]; a[i]=a[j]; a[j]=t;
    }
    return a;
  }

  function analyze(tokens, alpha, settings){
    const n = tokens.length;
    const uniq = uniqueCount(tokens);
    const H = shannonEntropyBits(tokens);
    const H1 = transitionEntropyBits(tokens);
    const maxLag = clamp(settings.maxLag, 10, Math.min(300, n-2));
    const {lags, ac} = acf(tokens, maxLag);
    const tauHat = fitExpTau(ac);
    const acAreaPos = positiveArea(ac);
    const acAreaW = kernelWeightedACFArea(ac, settings.tau);
    const scoreObj = coherenceScore(H, H1, acAreaW, Math.max(uniq, 2), maxLag);

    return {
      n, uniq, alpha,
      H, H1,
      maxLag,
      acf: {lags, ac},
      acAreaPos,
      acAreaW,
      tauHat,
      score: scoreObj.score,
      score_parts: scoreObj
    };
  }

  function setKV(res, delta=null){
    $("kv_tokens").textContent = res ? String(res.n) : "—";
    $("kv_alpha").textContent = res ? String(res.uniq) : "—";
    $("kv_H").textContent = res ? `${fmt(res.H,4)} (max ~${fmt(Math.log2(Math.max(2,res.uniq)),4)})` : "—";
    $("kv_H1").textContent = res ? `${fmt(res.H1,4)}` : "—";
    $("kv_acfA").textContent = res ? `${fmt(res.acAreaPos,4)} | w:${fmt(res.acAreaW,4)}` : "—";
    $("kv_tauhat").textContent = res && res.tauHat ? `${fmt(res.tauHat,2)} tokens` : "—";
    $("kv_score").textContent = res ? `${fmt(res.score,4)}  (h=${fmt(res.score_parts.h,3)} h1=${fmt(res.score_parts.h1,3)} a=${fmt(res.score_parts.a,3)})` : "—";
    $("kv_delta").textContent = (delta===null) ? "—" : `${fmt(delta,4)}`;
  }

  function buildTokens(){
    const raw = $("numIn").value || "";
    const mode = $("tokenMode").value;
    const maxN = clamp(parseInt($("maxN").value||"1200",10), 50, 5000);

    if (mode === "base26"){
      const d = digitsOnly(raw);
      const r = tokenizeBase26FromBigInt(d, maxN);
      if (r.err){
        log("Base-26: BigInt parse failed (input too large or invalid). Falling back to digits.");
        return tokenizeDigits(d, maxN);
      }
      return r;
    }
    const d = digitsOnly(raw);
    if (!d.length) return {tokens:[], alpha:0, kind:"none"};
    if (mode === "digits") return tokenizeDigits(d, maxN);
    if (mode === "pairs") return tokenizeChunks(d, 2, maxN);
    return tokenizeChunks(d, 3, maxN);
  }

  function runOnce(kind="main", tokensOverride=null){
    const settings = {
      tau: clamp(parseFloat($("tau").value||"28"), 1, 5000),
      sig2: clamp(parseFloat($("sig2").value||"0.36"), 0.0001, 99),
      maxLag: clamp(parseInt($("maxLag").value||"90",10), 10, 300),
    };

    const pack = tokensOverride ? tokensOverride : buildTokens();
    const tokens = pack.tokens;
    if (!tokens || tokens.length < 10){
      setStatus("need more data");
      log("Not enough tokens to analyze (need ≥ 10).");
      return null;
    }
    const alpha = pack.alpha || Math.max(2, uniqueCount(tokens));
    const res = analyze(tokens, alpha, settings);

    // draw
    drawACF($("acfCanvas"), res.acf.lags, res.acf.ac, res.tauHat);

    // output state
    last = res;
    setKV(res, (lastNull && lastNull.score!=null) ? (res.score - lastNull.score) : null);
    const payload = buildPayload(pack, res, lastNull, settings);
    outBox.textContent = JSON.stringify(payload, null, 2);
    setStatus("done");
    log(`${kind}: n=${res.n} uniq=${res.uniq} H=${fmt(res.H,3)} H1=${fmt(res.H1,3)} score=${fmt(res.score,4)} tauHat=${res.tauHat?fmt(res.tauHat,1):"—"}`);
    return res;
  }

  function buildPayload(pack, res, nullRes, settings){
    const mode = $("tokenMode").value;
    const rawDigits = digitsOnly($("numIn").value||"");
    const obj = {
      tool: "QDS Number Coherence Lab v1",
      ts: new Date().toISOString(),
      input: { mode, kind: pack.kind, raw_len: ($("numIn").value||"").length, digits_len: rawDigits.length },
      settings,
      result: res,
      null_model: nullRes ? { score: nullRes.score, H: nullRes.H, H1: nullRes.H1, tauHat: nullRes.tauHat } : null
    };
    return obj;
  }

  function runNull(){
    const pack = buildTokens();
    const tokens = pack.tokens;
    if (!tokens || tokens.length < 10){
      setStatus("need more data");
      log("Null: not enough tokens.");
      return;
    }
    setStatus("null…");
    const shuffled = shuffleCopy(tokens);
    const settings = {
      tau: clamp(parseFloat($("tau").value||"28"), 1, 5000),
      sig2: clamp(parseFloat($("sig2").value||"0.36"), 0.0001, 99),
      maxLag: clamp(parseInt($("maxLag").value||"90",10), 10, 300),
    };
    lastNull = analyze(shuffled, pack.alpha || Math.max(2, uniqueCount(shuffled)), settings);
    log(`null: score=${fmt(lastNull.score,4)} (Δ pending next run)`);
    if (last){
      setKV(last, last.score - lastNull.score);
      const payload = buildPayload(pack, last, lastNull, settings);
      outBox.textContent = JSON.stringify(payload, null, 2);
    }
    setStatus("done");
  }

  function runMCNull(iters=50){
    const pack = buildTokens();
    const tokens = pack.tokens;
    if (!tokens || tokens.length < 10){
      setStatus("need more data");
      log("MC null: not enough tokens.");
      return;
    }
    const settings = {
      tau: clamp(parseFloat($("tau").value||"28"), 1, 5000),
      sig2: clamp(parseFloat($("sig2").value||"0.36"), 0.0001, 99),
      maxLag: clamp(parseInt($("maxLag").value||"90",10), 10, 300),
    };
    setStatus("MC null…");
    let s=0, s2=0;
    for(let k=0;k<iters;k++){
      const sh = shuffleCopy(tokens);
      const r = analyze(sh, pack.alpha || Math.max(2, uniqueCount(sh)), settings);
      s += r.score; s2 += r.score*r.score;
    }
    const mu = s/iters;
    const varr = Math.max(0, s2/iters - mu*mu);
    const sd = Math.sqrt(varr);
    lastNull = {score: mu, sd};
    log(`MC null x${iters}: mean=${fmt(mu,4)} sd=${fmt(sd,4)} z=${(last?fmt((last.score-mu)/(sd||1),3):"—")}`);
    if (last){
      setKV(last, last.score - mu);
      // annotate payload
      const rawDigits = digitsOnly($("numIn").value||"");
      const payload = {
        tool:"QDS Number Coherence Lab v1",
        ts:new Date().toISOString(),
        input:{mode:$("tokenMode").value, kind:pack.kind, raw_len:($("numIn").value||"").length, digits_len:rawDigits.length},
        settings,
        result:last,
        null_model:{mc_iters:iters, mean:mu, sd:sd, delta:last.score-mu, z:(last.score-mu)/(sd||1)}
      };
      outBox.textContent = JSON.stringify(payload, null, 2);
    }
    setStatus("done");
  }

  // ===== Hebrew numeral lab (3-digit groups) =====

  const HEB = [
    {v:400, l:"ת"}, {v:300, l:"ש"}, {v:200, l:"ר"}, {v:100, l:"ק"},
    {v:90, l:"צ"},  {v:80,  l:"פ"}, {v:70,  l:"ע"}, {v:60,  l:"ס"}, {v:50, l:"נ"}, {v:40,l:"מ"},
    {v:30, l:"ל"},  {v:20,  l:"כ"}, {v:10,  l:"י"},
    {v:9,  l:"ט"},  {v:8,   l:"ח"}, {v:7,   l:"ז"}, {v:6,  l:"ו"}, {v:5,l:"ה"}, {v:4,l:"ד"}, {v:3,l:"ג"}, {v:2,l:"ב"}, {v:1,l:"א"},
  ];

  function hebSpell_0_999(n){
    n = Math.floor(Math.abs(n));
    n = clamp(n, 0, 999);
    if (n === 0) return "—"; // keep visible
    // 15/16 convention: use טו, טז instead of יה, יו
    // We'll implement at tens/ones stage.
    let out = "";
    let rem = n;

    // hundreds (>=100)
    for (const t of HEB){
      if (t.v >= 100){
        while(rem >= t.v){
          out += t.l;
          rem -= t.v;
        }
      }
    }

    // tens/ones with special-case
    if (rem === 15){ out += "טו"; return out; }
    if (rem === 16){ out += "טז"; return out; }

    // tens then ones
    for (const t of HEB){
      if (t.v < 100){
        while(rem >= t.v){
          out += t.l;
          rem -= t.v;
        }
      }
    }
    return out;
  }

  function hebBlocksFromDigits(d){
    const k=3;
    const n = Math.floor(d.length/k);
    const blocks = [];
    for(let i=0;i<n;i++){
      const chunk = parseInt(d.slice(i*k, i*k+k), 10);
      blocks.push({chunk, heb: hebSpell_0_999(chunk)});
    }
    return blocks;
  }

  function seamScanHebrew(blocks){
    // Make a continuous string (strip separators), and detect watchlist hits by scanning.
    const watchOn = $("hebWatchOn").checked;
    const watch = ["מהר","את","סדר","עזר","רצו","שנו","שלח","תשלח"];
    const parts = blocks.map(b => (b.heb==="—" ? "" : b.heb));
    const joined = parts.join("");
    const seams = [];

    // seam-specific: take last 2 of prev + first 2 of next, test any watch word
    for(let i=0;i<parts.length-1;i++){
      const a = parts[i], b = parts[i+1];
      if (!a || !b) continue;
      const a2 = a.slice(Math.max(0,a.length-2));
      const b2 = b.slice(0,2);
      const seam4 = a2 + b2;

      const hits = [];
      if (watchOn){
        for (const w of watch){
          if (seam4.includes(w)) hits.push(w);
        }
      }
      if (hits.length){
        seams.push({i, seam: seam4, hits});
      }
    }

    // also scan within the joined string for watch hits (positioned)
    const globalHits = [];
    if (watchOn){
      for(const w of watch){
        let idx = joined.indexOf(w);
        while(idx !== -1){
          globalHits.push({w, pos: idx});
          idx = joined.indexOf(w, idx+1);
        }
      }
      globalHits.sort((p,q)=>p.pos-q.pos);
    }
    return {joined, seams, globalHits};
  }

  // ===== Tabs =====
  function setTab(id){
    for(const el of document.querySelectorAll("[data-tab]")){
      el.classList.toggle("on", el.dataset.tab === id);
    }
    $("t_main").classList.toggle("hide", id !== "t_main");
    $("t_hebrew").classList.toggle("hide", id !== "t_hebrew");
    $("t_export").classList.toggle("hide", id !== "t_export");
  }
  document.querySelectorAll("[data-tab]").forEach(el=>{
    el.addEventListener("click", ()=>setTab(el.dataset.tab));
  });

  // ===== Buttons =====
  $("runBtn").addEventListener("click", ()=>{
    setStatus("running…");
    const res = runOnce("main");
    if ($("mcOn").checked) runMCNull(50);
  });

  $("nullBtn").addEventListener("click", ()=>{
    if ($("mcOn").checked) runMCNull(50);
    else runNull();
  });

  $("resetBtn").addEventListener("click", ()=>{
    last = null; lastNull = null;
    setKV(null, null);
    outBox.textContent = "Run analysis to populate…";
    logBox.textContent = "";
    $("hebBlocks").textContent = "—";
    $("hebSeams").textContent = "—";
    setStatus("ready");
  });

  $("hebRunBtn").addEventListener("click", ()=>{
    const d = digitsOnly($("numIn").value||"");
    if (d.length < 6){
      $("hebBlocks").textContent = "Need at least 6 digits (two triplets).";
      $("hebSeams").textContent = "—";
      return;
    }
    const blocks = hebBlocksFromDigits(d);
    const pretty = blocks.map(b => `${String(b.chunk).padStart(3,"0")} → ${b.heb}`).join("\n");
    $("hebBlocks").textContent = pretty;

    const seam = seamScanHebrew(blocks);
    const seamLines = [];
    seamLines.push("joined:");
    seamLines.push(seam.joined || "—");
    seamLines.push("\nseam hits (boundary 4-letters, watchlist):");
    seam.seams.forEach(s=>{
      seamLines.push(`#${s.i}: ${s.seam}  hits=[${s.hits.join(", ")}]`);
    });
    if (!seam.seams.length) seamLines.push("(none)");
    seamLines.push("\nglobal watch hits (joined string):");
    seam.globalHits.forEach(h=>{
      seamLines.push(`${h.w} @ ${h.pos}`);
    });
    if (!seam.globalHits.length) seamLines.push("(none)");
    $("hebSeams").textContent = seamLines.join("\n");
    log("hebrew: built blocks + seam scan");
  });

  // ===== Export =====
  function dl(filename, text){
    const blob = new Blob([text], {type:"text/plain"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 250);
  }

  $("copyJsonBtn").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(outBox.textContent || "");
      log("export: JSON copied to clipboard");
    }catch(e){
      log("export: clipboard copy failed (browser permission). Use download.");
    }
  });
  $("dlJsonBtn").addEventListener("click", ()=>{
    const txt = outBox.textContent || "{}";
    dl("qds_number_coherence_result.json", txt);
    log("export: JSON downloaded");
  });
  $("dlTxtBtn").addEventListener("click", ()=>{
    const txt = outBox.textContent || "";
    const lines = [];
    lines.push("QDS Number Coherence Lab v1");
    lines.push(new Date().toISOString());
    lines.push("");
    if (last){
      lines.push(`tokens: ${last.n}`);
      lines.push(`uniq: ${last.uniq}`);
      lines.push(`H: ${last.H}`);
      lines.push(`H1: ${last.H1}`);
      lines.push(`tauHat: ${last.tauHat}`);
      lines.push(`score: ${last.score}`);
      if (lastNull && lastNull.score!=null){
        lines.push(`null_score: ${lastNull.score}`);
        lines.push(`delta: ${last.score - lastNull.score}`);
        if (lastNull.sd!=null) lines.push(`null_sd: ${lastNull.sd}`);
      }
    } else {
      lines.push("(no run yet)");
    }
    dl("qds_number_coherence_result.txt", lines.join("\n"));
    log("export: TXT downloaded");
  });

  // ===== Low-FX =====
  $("lowFx").addEventListener("change", ()=>{
    document.body.style.background = $("lowFx").checked ? "#0b0f14" : "";
  });

  // boot
  setStatus("ready");
  log("ready: paste number → Run analysis. Use Null model to sanity-check.");
})();
</script>
</body>
</html>
