<!doctype html><html><head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>QDS Genomics Coherence Lab v5 AutoTest</title>
<style>
:root{--bg:#0b0f14;--p:#111826;--ink:#e7eef7;--m:#9fb0c3;--l:#213045;--r:14px}
body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--ink)}
header{padding:14px 12px;border-bottom:1px solid var(--l);background:#0f1620}
h1{margin:0;font-size:17px}
.sub{margin-top:6px;color:var(--m);font-size:12.5px;line-height:1.35}
.wrap{padding:12px;max-width:1000px;margin:0 auto}
.card{background:var(--p);border:1px solid var(--l);border-radius:var(--r);padding:12px}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
label{font-size:12px;color:var(--m)}
input,select,textarea,button{box-sizing:border-box;background:#0c1320;border:1px solid var(--l);border-radius:12px;color:var(--ink);padding:10px}
input[type=file],select,button{width:100%}
input[type=range]{width:100%;padding:6px}
textarea{width:100%;min-height:120px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;resize:vertical}
button{cursor:pointer}
button:hover{border-color:#2d4666}
.grid{display:grid;grid-template-columns:1fr;gap:10px}
@media(min-width:900px){.grid{grid-template-columns:1fr 1fr}}
.kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
.k{background:#0c1320;border:1px solid var(--l);border-radius:12px;padding:10px}
.t{color:var(--m);font-size:12px}
.v{margin-top:4px;font-size:16px;font-family:ui-monospace,Menlo,Consolas,monospace}
.s{margin-top:4px;color:var(--m);font-size:12px;line-height:1.25}
hr{border:none;border-top:1px solid var(--l);margin:10px 0}
pre{white-space:pre-wrap;margin:0}
canvas{width:100%;height:180px;border:1px solid var(--l);border-radius:12px;background:#0c1320}
.small{color:var(--m);font-size:12px;line-height:1.35}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
.badge{display:inline-block;padding:2px 8px;border:1px solid var(--l);border-radius:999px;color:var(--m);font-size:12px}
</style></head><body>
<header>
  <h1>QDS Genomics Coherence Lab v5 ‚Äî AutoTest</h1>
  <div class="sub">One parse, many sweeps. Sliders control hpWin + œÅCut + maxLag. AutoTest runs your standard sweeps (œÅCut + hpWin) and graphs œÅ(k) + D_eff sweep. Offline. Phone-safe. ü¶∫üé©üí•</div>
</header>

<div class="wrap"><div class="card">
  <label>1) Load 23andMe raw data (.txt)</label>
  <input id="file" type="file" accept=".txt,.tsv,.csv">

  <div class="grid" style="margin-top:10px">
    <div>
      <label>Short window (bp) ‚Äî LD-ish</label>
      <input id="wShort" type="number" min="10000" max="200000" value="50000">
    </div>
    <div>
      <label>Long window (bp) ‚Äî haplotype-ish</label>
      <input id="wLong" type="number" min="200000" max="5000000" value="1000000">
    </div>
  </div>

  <div class="grid" style="margin-top:10px">
    <div>
      <label>Detrend</label>
      <select id="detrend">
        <option value="hp" selected>High-pass (recommended)</option>
        <option value="diff">ŒîX (edge detector)</option>
        <option value="both">HP then ŒîX (aggressive)</option>
        <option value="none">None (may inflate)</option>
      </select>
    </div>
    <div>
      <label>SNP sanity lane: sampling step</label>
      <input id="snpStep" type="number" min="1" max="30" value="8">
    </div>
  </div>

  <hr>

  <div class="grid">
    <div>
      <label>hpWin (windows): <span class="badge" id="hpLbl">13</span></label>
      <input id="hpWin" type="range" min="5" max="31" step="2" value="13">
    </div>
    <div>
      <label>œÅCut (abs-œÅ tail cutoff): <span class="badge" id="rhoLbl">0.02</span></label>
      <input id="rhoCut" type="range" min="0.00" max="0.08" step="0.01" value="0.02">
    </div>
    <div>
      <label>maxLag (windows): <span class="badge" id="lagLbl">200</span></label>
      <input id="maxLag" type="range" min="60" max="260" step="20" value="200">
    </div>
    <div>
      <label>Per-chrom stability lag (windows)</label>
      <input id="chrLag" type="number" min="20" max="120" value="60">
    </div>
  </div>

  <div class="grid" style="margin-top:10px">
    <div>
      <label>Trait weights (rsID effect_allele beta)</label>
      <textarea id="traits" spellcheck="false" placeholder="rs4988235 T 0.40&#10;rs762551 A 0.25"></textarea>
    </div>
    <div>
      <label>Watchlist rsIDs (lookup-only)</label>
      <input id="watch" type="text" placeholder="rs4988235 rs762551 rs12913832">
      <div class="small" style="margin-top:8px">Tip: AutoTest assumes detrend stays fixed, and sweeps <span class="mono">œÅCut=[0.01,0.02,0.03]</span> and <span class="mono">hpWin=[9,13,17]</span>.</div>
    </div>
  </div>

  <div class="row" style="margin-top:10px">
    <button id="build">ü¶∫ Build (current sliders)</button>
    <button id="auto">üí• AutoTest sweeps</button>
    <button id="copy">Copy readout</button>
  </div>

  <pre id="status" class="small" style="margin-top:10px">Waiting for file‚Ä¶</pre>

  <div class="kpi">
    <div class="k"><div class="t">D_raw</div><div class="v" id="k_raw">‚Äî</div><div class="s">called SNPs</div></div>
    <div class="k"><div class="t">Missing</div><div class="v" id="k_miss">‚Äî</div><div class="s">missing rate</div></div>
    <div class="k"><div class="t">Œª short / long</div><div class="v" id="k_lam">‚Äî</div><div class="s">interp 1/e crossing</div></div>
    <div class="k"><div class="t">Red(win) / Red(SNP)</div><div class="v" id="k_red">‚Äî</div><div class="s">abs-œÅ tail cutoff</div></div>
    <div class="k"><div class="t">D_eff</div><div class="v" id="k_deff">‚Äî</div><div class="s">called / Red(win)</div></div>
    <div class="k"><div class="t">Stability short / long</div><div class="v" id="k_stab">‚Äî</div><div class="s">median + IQR</div></div>
  </div>

  <hr>
  <div class="grid">
    <div>
      <div class="small"><b>Graph 1:</b> œÅ(k) ‚Äî short window (detrended)</div>
      <canvas id="cRho"></canvas>
    </div>
    <div>
      <div class="small"><b>Graph 2:</b> AutoTest D_eff sweep</div>
      <canvas id="cSweep"></canvas>
    </div>
  </div>

  <hr>
  <div class="small"><b>Readout box (copy/paste)</b></div>
  <textarea id="readout" spellcheck="false"></textarea>

  <hr>
  <div class="small"><b>Trait panel</b></div>
  <pre id="traitOut" class="small">No traits yet.</pre>

  <div class="small"><b>Watchlist</b></div>
  <pre id="watchOut" class="small">No watchlist yet.</pre>

  <div class="small"><b>Per-chrom counts</b></div>
  <pre id="chromOut" class="small mono">‚Äî</pre>
</div></div>

<script>
const el=id=>document.getElementById(id);
const status=t=>el("status").textContent=t;
const fmtInt=x=>isFinite(x)?Math.round(x).toString().replace(/\B(?=(\d{3})+(?!\d))/g,","):"‚Äî";
const fmtPct=x=>isFinite(x)?(x*100).toFixed(2)+"%":"‚Äî";
function fmtBp(x){ if(!isFinite(x)||x<=0) return "‚Äî"; if(x>=1e6) return (x/1e6).toFixed(2)+" Mb"; if(x>=1e3) return (x/1e3).toFixed(1)+" kb"; return Math.round(x)+" bp"; }
function safeChrom(ch){
  const c=(ch||"").toUpperCase();
  if(c==="X"||c==="Y"||c==="MT"||c==="M") return c==="M"?"MT":c;
  const n=parseInt(c,10);
  if(isFinite(n)&&n>=1&&n<=22) return String(n);
  return null;
}
function sortGt(gt){
  if(!gt||gt.length<2) return null;
  const a=gt[0],b=gt[1];
  if(!"ACGT".includes(a)||!"ACGT".includes(b)) return null;
  return (a<=b)?gt:(b+a);
}
function gtDosage(gt, ea){
  if(!gt||gt.length<2) return null;
  const a=gt[0],b=gt[1];
  if(!"ACGT".includes(a)||!"ACGT".includes(b)) return null;
  return (a===ea)+(b===ea);
}
function entropyFromCounts(counts){
  let n=0; for(const k in counts) n+=counts[k];
  if(n<=0) return 0;
  let H=0;
  for(const k in counts){
    const c=counts[k]; if(c<=0) continue;
    const p=c/n; H -= p*Math.log2(p);
  }
  return H;
}
function zscore(a){
  const n=a.length; if(n<2) return a.slice();
  let m=0; for(let i=0;i<n;i++) m+=a[i]; m/=n;
  let v=0; for(let i=0;i<n;i++){ const d=a[i]-m; v+=d*d; } v/=n;
  const s=Math.sqrt(v)||1;
  const out=new Array(n);
  for(let i=0;i<n;i++) out[i]=(a[i]-m)/s;
  return out;
}
function highPass(a, win){
  const n=a.length, w=Math.max(1, Math.floor(win));
  const out=new Array(n).fill(0);
  let sum=0; const q=[];
  for(let i=0;i<n;i++){
    sum+=a[i]; q.push(a[i]);
    if(q.length>w) sum-=q.shift();
    out[i]=a[i]-(sum/q.length);
  }
  return out;
}
function diff(a){
  const n=a.length; if(n<2) return [];
  const out=new Array(n-1);
  for(let i=1;i<n;i++) out[i-1]=a[i]-a[i-1];
  return out;
}
function autocorr(a, maxLag){
  const n=a.length;
  if(n<maxLag+10) return null;
  let m=0; for(let i=0;i<n;i++) m+=a[i]; m/=n;
  let v=0; for(let i=0;i<n;i++){ const d=a[i]-m; v+=d*d; } v/=n;
  if(v<=1e-12) return null;
  const r=new Array(maxLag+1).fill(0); r[0]=1;
  for(let k=1;k<=maxLag;k++){
    const m2=n-k;
    let cov=0;
    for(let i=0;i<m2;i++) cov+=(a[i]-m)*(a[i+k]-m);
    r[k]=(cov/m2)/v;
  }
  return r;
}
function combineAutocorr(perChr, maxLag){
  const r=new Array(maxLag+1).fill(0), w=new Array(maxLag+1).fill(0);
  r[0]=1; w[0]=1;
  for(const chr of Object.keys(perChr)){
    const a=perChr[chr];
    if(!a||a.length<maxLag+12) continue;
    const rr=autocorr(a,maxLag); if(!rr) continue;
    const n=a.length;
    for(let k=1;k<=maxLag;k++){
      const pairs=Math.max(0,n-k);
      r[k]+=rr[k]*pairs; w[k]+=pairs;
    }
  }
  for(let k=1;k<=maxLag;k++) r[k]=(w[k]>0)?(r[k]/w[k]):0;
  return r;
}
function estimateLambdaInterp(rhos){
  const thr=1/Math.E;
  for(let k=1;k<rhos.length;k++){
    const a=rhos[k-1], b=rhos[k];
    if(a>=thr && b<=thr){
      const t=(thr-a)/(b-a);
      return (k-1)+t;
    }
  }
  if(rhos.length>1 && rhos[1]>0 && rhos[1]<1){
    const kstar=-1/Math.log(rhos[1]);
    if(isFinite(kstar)&&kstar>0) return kstar;
  }
  return rhos.length-1;
}
function redundancyAbs(rhos, rhoCut){
  let s=0;
  for(let k=1;k<rhos.length;k++){
    const rk=Math.abs(rhos[k]);
    if(rk<=rhoCut) break;
    s += rk;
  }
  return 1 + 2*s;
}
function quantiles(arr){
  const a=arr.filter(x=>isFinite(x)).slice().sort((x,y)=>x-y);
  if(!a.length) return null;
  const q=p=>{
    const i=(a.length-1)*p, lo=Math.floor(i), hi=Math.ceil(i);
    if(lo===hi) return a[lo];
    const t=i-lo;
    return a[lo]*(1-t)+a[hi]*t;
  };
  return {n:a.length, p25:q(0.25), p50:q(0.5), p75:q(0.75)};
}
function parseWatchlist(txt){
  const s=(txt||"").trim(); if(!s) return new Set();
  return new Set(s.split(/[\s,;]+/).map(x=>x.trim().toLowerCase()).filter(x=>x.startsWith("rs")));
}
function parseTraits(txt){
  const map=new Map();
  for(const raw of (txt||"").split(/\r?\n/)){
    const line=raw.trim();
    if(!line||line.startsWith("#")) continue;
    const p=line.split(/\s+/); if(p.length<3) continue;
    const rs=p[0].toLowerCase(), ea=p[1].toUpperCase(), beta=parseFloat(p[2]);
    if(!rs.startsWith("rs")) continue;
    if(!"ACGT".includes(ea)) continue;
    if(!isFinite(beta)) continue;
    map.set(rs,{ea,beta});
  }
  return map;
}
class WinAgg{
  constructor(wbp){this.wbp=wbp; this.cur=null; this.wi=null; this.reset();}
  reset(){this.counts={}; this.n=0; this.ch=0; this.het=0; this.prev=null;}
  flush(out){
    if(this.cur===null) return;
    if(!out[this.cur]) out[this.cur]=[];
    if(this.n>0){
      const H=entropyFromCounts(this.counts);
      const cd=(this.n>1)?(this.ch/(this.n-1)):0;
      const hr=this.het/this.n;
      out[this.cur].push(0.45*H + 0.35*cd + 0.20*hr);
    }
    this.reset();
  }
  push(chr,pos,gt,out){
    if(this.cur!==chr){ if(this.cur!==null) this.flush(out); this.cur=chr; this.wi=null; this.reset(); }
    const wi=Math.floor(pos/this.wbp);
    if(this.wi===null) this.wi=wi;
    if(wi!==this.wi){ this.flush(out); this.wi=wi; }
    const g=sortGt(gt); if(!g) return;
    this.counts[g]=(this.counts[g]||0)+1;
    if(g[0]!==g[1]) this.het++;
    if(this.prev!==null && g!==this.prev) this.ch++;
    this.prev=g; this.n++;
  }
  finish(out){ this.flush(out); this.cur=null; }
}
function applyDetrend(series, mode, hpWin){
  let a=zscore(series);
  if(mode==="hp") a=highPass(a,hpWin);
  else if(mode==="diff") a=diff(a);
  else if(mode==="both"){ a=highPass(a,hpWin); a=diff(a); }
  else if(mode==="none"){}
  if(a.length>=2) a=zscore(a);
  return a;
}

// ---------- Caching layer (parse once) ----------
const CACHE = {
  parsed:false, textHash:"",
  called:0, missing:0, total:0,
  chromC:{}, chromM:{},
  perS_raw:{}, perL_raw:{}, // window signals before detrend
  hetByChr:{}, // SNP sanity lane (0/1)
  watchHits:{}, traitDetails:[], traitMeta:null,
};

function clearCache(){
  CACHE.parsed=false; CACHE.textHash="";
  CACHE.called=0; CACHE.missing=0; CACHE.total=0;
  CACHE.chromC={}; CACHE.chromM={};
  CACHE.perS_raw={}; CACHE.perL_raw={};
  CACHE.hetByChr={};
  CACHE.watchHits={}; CACHE.traitDetails=[]; CACHE.traitMeta=null;
}

async function parseTextOnce(text){
  clearCache();
  const wS=+el("wShort").value||50000, wL=+el("wLong").value||1000000;
  const snpStep=+el("snpStep").value||8;

  const watch=parseWatchlist(el("watch").value);
  const traits=parseTraits(el("traits").value);

  const aggS=new WinAgg(wS), aggL=new WinAgg(wL);
  const snpSeen={};
  const lines=text.split(/\r?\n/);

  status("Parsing once‚Ä¶ "+lines.length.toLocaleString()+" lines");
  for(let i=0;i<lines.length;i++){
    const line=lines[i];
    if(!line||line[0]==="#") continue;
    const p=line.split(/\t|,/);
    if(p.length<4) continue;

    const rs=(p[0]||"").trim().toLowerCase();
    const chr=safeChrom((p[1]||"").trim());
    const pos=parseInt((p[2]||"").trim(),10);
    const gt=(p[3]||"").trim().toUpperCase();
    if(!chr||!isFinite(pos)) continue;

    CACHE.total++;
    if(gt==="--"||gt.length<2){
      CACHE.missing++; CACHE.chromM[chr]=(CACHE.chromM[chr]||0)+1;
      continue;
    }
    CACHE.called++; CACHE.chromC[chr]=(CACHE.chromC[chr]||0)+1;

    aggS.push(chr,pos,gt,CACHE.perS_raw);
    aggL.push(chr,pos,gt,CACHE.perL_raw);

    snpSeen[chr]=(snpSeen[chr]||0)+1;
    if((snpSeen[chr]%snpStep)===0){
      const g=sortGt(gt);
      if(g){
        if(!CACHE.hetByChr[chr]) CACHE.hetByChr[chr]=[];
        CACHE.hetByChr[chr].push(g[0]!==g[1]?1:0);
      }
    }

    if(watch.size && watch.has(rs)) CACHE.watchHits[rs]={chr,pos,gt};

    if(traits.size && traits.has(rs)){
      const {ea,beta}=traits.get(rs);
      const d=gtDosage(gt,ea);
      if(d!==null){
        CACHE.traitDetails.push({rs,chr,pos,gt,ea,beta,d,contrib:beta*d});
      }
    }

    if(i%150000===0 && i>0) status("Parsing‚Ä¶ line "+i.toLocaleString());
  }
  aggS.finish(CACHE.perS_raw);
  aggL.finish(CACHE.perL_raw);

  CACHE.parsed=true;
  status("Parsed once. Ready to compute fast sweeps. üé©");
}

function computeFromCache(params){
  if(!CACHE.parsed) return null;
  const detr=params.detrend;
  const hpWin=params.hpWin;
  const rhoCut=params.rhoCut;
  const maxLag=params.maxLag;
  const chrLag=params.chrLag;
  const wS=+el("wShort").value||50000, wL=+el("wLong").value||1000000;

  // detrend window signals
  const perSd={}, perLd={};
  for(const chr of Object.keys(CACHE.perS_raw)){
    const a=CACHE.perS_raw[chr]; if(!a||a.length<15) continue;
    const d=applyDetrend(a,detr,hpWin); if(d.length<15) continue;
    perSd[chr]=d;
  }
  for(const chr of Object.keys(CACHE.perL_raw)){
    const a=CACHE.perL_raw[chr]; if(!a||a.length<15) continue;
    const d=applyDetrend(a,detr,hpWin); if(d.length<15) continue;
    perLd[chr]=d;
  }

  const rS=combineAutocorr(perSd,Math.min(260,Math.max(40,maxLag)));
  const rL=combineAutocorr(perLd,Math.min(160,Math.max(40,Math.floor(maxLag*0.8))));
  const lagS=estimateLambdaInterp(rS), lagL=estimateLambdaInterp(rL);
  const lamS=lagS*wS, lamL=lagL*wL;

  const redWin=redundancyAbs(rS,rhoCut);
  const deff=(isFinite(redWin)&&redWin>0)?(CACHE.called/redWin):NaN;

  const rSnp=combineAutocorr(CACHE.hetByChr,Math.min(220,Math.max(60,Math.floor(maxLag*0.9))));
  const redSnp=redundancyAbs(rSnp,rhoCut);

  // per-chr Œª stability
  const lamShortChr=[], lamLongChr=[];
  for(const chr of Object.keys(perSd)){
    const rr=autocorr(perSd[chr],Math.min(120,chrLag)); if(!rr) continue;
    lamShortChr.push(estimateLambdaInterp(rr)*wS);
  }
  for(const chr of Object.keys(perLd)){
    const rr=autocorr(perLd[chr],Math.min(120,chrLag)); if(!rr) continue;
    lamLongChr.push(estimateLambdaInterp(rr)*wL);
  }
  const qs=quantiles(lamShortChr), ql=quantiles(lamLongChr);

  const missRate=CACHE.total?CACHE.missing/CACHE.total:NaN;

  // trait summary (no external db; you supply EA/beta)
  const traitsProvided=parseTraits(el("traits").value).size;
  let traitFound=0, traitScore=0; const td=CACHE.traitDetails.slice();
  const traitWinS=new Set(), traitWinL=new Set();
  for(const d of td){
    traitFound++; traitScore+=d.contrib;
    traitWinS.add(d.chr+":"+Math.floor(d.pos/wS));
    traitWinL.add(d.chr+":"+Math.floor(d.pos/wL));
  }
  td.sort((a,b)=>Math.abs(b.contrib)-Math.abs(a.contrib));
  const top=td.slice(0,12);

  return {
    called:CACHE.called, missing:CACHE.missing, missRate,
    wS,wL, detr, hpWin, rhoCut, maxLag, chrLag,
    lamS, lamL, redWin, redSnp, deff,
    qs, ql,
    rS, // for plotting
    trait:{provided:traitsProvided, found:traitFound, score:traitScore, uniqueS:traitWinS.size, uniqueL:traitWinL.size, top},
  };
}

// ---------- tiny plotting (canvas) ----------
function drawLine(canvas, xs, ys, yMin, yMax, title){
  const c=canvas, ctx=c.getContext("2d");
  const W=c.width=canvas.clientWidth*2, H=c.height=canvas.clientHeight*2;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#0c1320"; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle="#213045"; ctx.lineWidth=2;
  ctx.strokeRect(2,2,W-4,H-4);
  // title
  ctx.fillStyle="#9fb0c3"; ctx.font="24px ui-monospace,Menlo,Consolas";
  ctx.fillText(title||"", 18, 34);

  if(xs.length<2) return;
  const padL=60, padR=20, padT=50, padB=50;
  const x0=padL, x1=W-padR, y0=padT, y1=H-padB;
  // axes
  ctx.strokeStyle="#213045"; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.lineTo(x1,y1); ctx.stroke();

  // 0-line if in range
  if(yMin<0 && yMax>0){
    const yy=y1-(0-yMin)/(yMax-yMin)*(y1-y0);
    ctx.strokeStyle="#213045";
    ctx.beginPath(); ctx.moveTo(x0,yy); ctx.lineTo(x1,yy); ctx.stroke();
  }

  ctx.strokeStyle="#e7eef7"; ctx.lineWidth=3;
  ctx.beginPath();
  for(let i=0;i<xs.length;i++){
    const xx=x0+(xs[i]-xs[0])/(xs[xs.length-1]-xs[0]+1e-9)*(x1-x0);
    const yy=y1-(ys[i]-yMin)/(yMax-yMin+1e-9)*(y1-y0);
    if(i===0) ctx.moveTo(xx,yy); else ctx.lineTo(xx,yy);
  }
  ctx.stroke();

  // y labels
  ctx.fillStyle="#9fb0c3"; ctx.font="22px ui-monospace,Menlo,Consolas";
  ctx.fillText(yMax.toFixed(2), 10, y0+8);
  ctx.fillText(yMin.toFixed(2), 10, y1+8);
}

function plotRhoShort(rS){
  const xs=[], ys=[];
  const K=Math.min(120, rS.length-1);
  for(let k=0;k<=K;k++){ xs.push(k); ys.push(rS[k]); }
  // clamp view
  let yMin=-0.4, yMax=1.0;
  drawLine(el("cRho"), xs, ys, yMin, yMax, "rho(k) short");
}

function plotSweep(points){
  // points: [{x,label,y}]
  const xs=[], ys=[];
  for(let i=0;i<points.length;i++){ xs.push(i); ys.push(points[i].y); }
  const yMin=Math.min(...ys)*0.995, yMax=Math.max(...ys)*1.005;
  drawLine(el("cSweep"), xs, ys, yMin, yMax, "D_eff sweep");
  // annotate in readout instead of cluttering canvas
}

// ---------- UI actions ----------
function updateSliderLabels(){
  el("hpLbl").textContent=el("hpWin").value;
  el("rhoLbl").textContent=(+el("rhoCut").value).toFixed(2);
  el("lagLbl").textContent=el("maxLag").value;
}
["hpWin","rhoCut","maxLag"].forEach(id=>el(id).addEventListener("input",updateSliderLabels));
updateSliderLabels();

function render(res, extraNote){
  el("k_raw").textContent=fmtInt(res.called);
  el("k_miss").textContent=fmtPct(res.missRate);
  el("k_lam").textContent=fmtBp(res.lamS)+" / "+fmtBp(res.lamL);
  el("k_red").textContent=res.redWin.toFixed(2)+"√ó / "+res.redSnp.toFixed(2)+"√ó";
  el("k_deff").textContent=fmtInt(res.deff);

  const qs=res.qs, ql=res.ql;
  const stab = (qs?("S med "+fmtBp(qs.p50)+" IQR "+fmtBp(qs.p25)+"‚Äì"+fmtBp(qs.p75)+" n="+qs.n):"S ‚Äî")
             + " | "
             + (ql?("L med "+fmtBp(ql.p50)+" IQR "+fmtBp(ql.p25)+"‚Äì"+fmtBp(ql.p75)+" n="+ql.n):"L ‚Äî");
  el("k_stab").textContent=stab;

  plotRhoShort(res.rS);

  // traits
  if(!res.trait.provided){
    el("traitOut").textContent="No traits.";
  }else{
    const cov = res.trait.provided? (res.trait.found/res.trait.provided) : 0;
    const redTrait = res.trait.uniqueS? (res.trait.found/res.trait.uniqueS) : NaN;
    el("traitOut").textContent =
`provided: ${res.trait.provided}
found: ${res.trait.found} (${fmtPct(cov)})
score: ${res.trait.score.toFixed(6)}
unique windows: ${res.trait.uniqueS} (short) / ${res.trait.uniqueL} (long)
trait redundancy(short): ${isFinite(redTrait)?redTrait.toFixed(2)+"√ó":"‚Äî"}

top:
${res.trait.top.map(d=>`${d.rs} chr${d.chr}:${d.pos} gt=${d.gt} ea=${d.ea} Œ≤=${d.beta} dose=${d.d} ‚Üí ${d.contrib.toFixed(4)}`).join("\n") || "(none)"}
`;
  }

  // watchlist
  const watch=parseWatchlist(el("watch").value);
  if(!watch.size) el("watchOut").textContent="No watchlist.";
  else{
    const items=[...watch].sort();
    el("watchOut").textContent=items.map(rs=>{
      const hit=CACHE.watchHits[rs];
      return hit?`${rs}: ${hit.gt} (chr${hit.chr}:${hit.pos})`:`${rs}: not found`;
    }).join("\n");
  }

  // per-chrom counts
  const keys=Object.keys(CACHE.chromC).sort((a,b)=>+a-+b);
  el("chromOut").textContent=keys.map(k=>`chr${k}: called=${CACHE.chromC[k]||0} missing=${CACHE.chromM[k]||0}`).join("\n");

  // readout box (copy/paste friendly)
  const read = {
    version:"v5_autotest",
    called:res.called, missing:res.missing, missing_rate:res.missRate,
    w_short_bp:res.wS, w_long_bp:res.wL,
    detrend:res.detr, hpWin:res.hpWin, rhoCut:res.rhoCut, maxLag:res.maxLag, chrLag:res.chrLag,
    lambda_short_bp:res.lamS, lambda_long_bp:res.lamL,
    redundancy_window:res.redWin, redundancy_snp:res.redSnp,
    d_eff:res.deff,
    stability_short_q:res.qs, stability_long_q:res.ql,
    note: extraNote || ""
  };
  el("readout").value = JSON.stringify(read,null,2);

  status(`Done (fast compute). Short Œª‚âà${fmtBp(res.lamS)} red‚âà${res.redWin.toFixed(2)}√ó D_eff‚âà${fmtInt(res.deff)} | Long Œª‚âà${fmtBp(res.lamL)} | ${extraNote||""}`.trim());
}

async function ensureParsed(){
  const f=el("file").files && el("file").files[0];
  if(!f){ status("No file selected."); return false; }
  if(CACHE.parsed) return true;
  status("Loading file‚Ä¶");
  const r=new FileReader();
  const txt = await new Promise((ok, bad)=>{
    r.onload=()=>ok(String(r.result||""));
    r.onerror=()=>bad(new Error("read error"));
    r.readAsText(f);
  });
  await parseTextOnce(txt);
  return true;
}

el("build").onclick=async()=>{
  if(!await ensureParsed()) return;
  const res = computeFromCache({
    detrend: el("detrend").value,
    hpWin: +el("hpWin").value,
    rhoCut: +el("rhoCut").value,
    maxLag: +el("maxLag").value,
    chrLag: +el("chrLag").value,
  });
  if(!res){ status("Compute failed (insufficient data after detrend?)."); return; }
  render(res, "single run");
};

el("auto").onclick=async()=>{
  if(!await ensureParsed()) return;

  const detr = el("detrend").value;
  const rhoCuts=[0.01,0.02,0.03];
  const hpWins=[9,13,17];

  status("AutoTest‚Ä¶ sweeping œÅCut √ó hpWin (fast, no re-parse)");
  const points=[];
  const rows=[];

  for(const hc of rhoCuts){
    for(const hw of hpWins){
      const res = computeFromCache({
        detrend:detr, hpWin:hw, rhoCut:hc,
        maxLag:+el("maxLag").value, chrLag:+el("chrLag").value
      });
      if(!res) continue;
      rows.push({rhoCut:hc, hpWin:hw, lamS:res.lamS, red:res.redWin, deff:res.deff, redSnp:res.redSnp});
      points.push({label:`œÅ${hc.toFixed(2)}-h${hw}`, y:res.deff});
    }
  }

  // plot sweep (D_eff)
  plotSweep(points);

  // keep current sliders result visible (compute once with current slider values)
  const cur = computeFromCache({
    detrend:detr,
    hpWin:+el("hpWin").value,
    rhoCut:+el("rhoCut").value,
    maxLag:+el("maxLag").value,
    chrLag:+el("chrLag").value
  });
  if(cur) render(cur, "AutoTest done");

  // append table to readout for copy/paste
  const header="rhoCut\thpWin\tlambda_short_bp\tred_win\tD_eff\tred_snp";
  const table=[header].concat(rows.map(r=>`${r.rhoCut.toFixed(2)}\t${r.hpWin}\t${Math.round(r.lamS)}\t${r.red.toFixed(3)}\t${Math.round(r.deff)}\t${r.redSnp.toFixed(3)}`)).join("\n");
  el("readout").value += "\n\n" + table + "\n";
};

el("copy").onclick=async()=>{
  const s=el("readout").value||"";
  try{ await navigator.clipboard.writeText(s); status("Copied readout. üé©"); }
  catch(e){ status("Clipboard blocked ‚Äî select text in the box and copy manually."); }
};
</script></body></html>
