<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>QDS Genomics Coherence Lab v1</title>
<style>
  :root{
    --bg:#0b0f14; --panel:#111826; --ink:#e7eef7; --muted:#9fb0c3;
    --line:#213045; --hot:#ffcc66; --ok:#90ee90; --bad:#ff7b7b;
    --radius:16px;
  }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--ink);}
  header{padding:16px 14px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,#0f1620,transparent);}
  h1{margin:0;font-size:18px;letter-spacing:.2px}
  .sub{margin-top:6px;color:var(--muted);font-size:13px;line-height:1.35}
  .wrap{padding:14px;max-width:980px;margin:0 auto;}
  .grid{display:grid;grid-template-columns:1fr;gap:12px;}
  @media (min-width:860px){ .grid{grid-template-columns:1.1fr .9fr;} }
  .card{background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);padding:12px;box-shadow:0 12px 26px rgba(0,0,0,.25);}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:12px;color:var(--muted)}
  input[type="file"]{width:100%;}
  input[type="number"], input[type="text"]{
    background:#0c1320;border:1px solid var(--line);border-radius:12px;color:var(--ink);
    padding:10px 10px;outline:none;width:100%;
  }
  button{
    background:#0c1320;border:1px solid var(--line);border-radius:12px;color:var(--ink);
    padding:10px 12px;cursor:pointer
  }
  button:hover{border-color:#2d4666}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid var(--line);color:var(--muted);font-size:12px}
  .pill strong{color:var(--ink)}
  .kpi{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px}
  .k{background:#0c1320;border:1px solid var(--line);border-radius:14px;padding:10px}
  .k .t{color:var(--muted);font-size:12px}
  .k .v{font-size:18px;margin-top:4px}
  .k .s{color:var(--muted);font-size:12px;margin-top:4px}
  hr{border:none;border-top:1px solid var(--line);margin:10px 0}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .small{font-size:12px;color:var(--muted);line-height:1.35}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid var(--line);padding:8px 6px;font-size:13px;text-align:left}
  th{color:var(--muted);font-weight:600}
  .good{color:var(--ok)} .warn{color:var(--hot)} .bad{color:var(--bad)}
  canvas{width:100%;height:220px;background:#0c1320;border:1px solid var(--line);border-radius:14px}
  .status{white-space:pre-wrap;font-size:12px;color:var(--muted);line-height:1.35}
  .two{display:grid;grid-template-columns:1fr;gap:10px}
  @media (min-width:860px){ .two{grid-template-columns:1fr 1fr;} }
</style>
</head>

<body>
<header>
  <h1>QDS Genomics Coherence Lab v1</h1>
  <div class="sub">
    Mainstream counts ‚ÄúSNP confetti‚Äù. QDS estimates <span class="mono">Œª‚Ççg‚Çé</span> (coherence length) and an <span class="mono">D_eff</span> ‚Äúeffective independent variation‚Äù.
    Offline. Phone-safe. No magic. Slightly rude Vikings optional.
  </div>
</header>

<div class="wrap">
  <div class="grid">
    <div class="card">
      <div class="row">
        <div class="pill">Mode: <strong>Mainstream vs QDS</strong></div>
        <div class="pill">Input: <strong>23andMe raw txt</strong></div>
        <div class="pill">Build: <strong>v1</strong></div>
      </div>

      <hr/>

      <label>1) Load 23andMe raw data (.txt)</label>
      <input id="file" type="file" accept=".txt,.tsv,.csv" />

      <div class="two" style="margin-top:10px">
        <div>
          <label>2) Sampling step (higher = faster on phones)</label>
          <input id="step" type="number" min="1" max="50" value="8" />
          <div class="small">Example: step=8 keeps ~1 in 8 SNPs per chromosome for coherence estimation.</div>
        </div>
        <div>
          <label>3) Max lag for autocorrelation (index lags)</label>
          <input id="maxLag" type="number" min="10" max="300" value="120" />
          <div class="small">Higher gives smoother Œª‚Ççg‚Çé but costs compute.</div>
        </div>
      </div>

      <div style="margin-top:10px">
        <label>Optional: Watchlist rsIDs (comma/space/newline). Example: rs4988235 rs762551</label>
        <input id="watch" type="text" placeholder="rs4988235 rs762551 rs12913832" />
        <div class="small">Watchlist is for quick ‚Äúlookup-only‚Äù outputs. No external databases used.</div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="run">ü¶∫ Build Metrics</button>
        <button id="demo">Load demo text (tiny)</button>
      </div>

      <div style="margin-top:10px" class="status" id="status">Waiting for file‚Ä¶</div>

      <hr/>

      <div class="kpi">
        <div class="k">
          <div class="t">Mainstream: D_raw (called SNPs)</div>
          <div class="v mono" id="k_raw">‚Äî</div>
          <div class="s">Counts genotype calls (non-missing)</div>
        </div>
        <div class="k">
          <div class="t">Missing rate</div>
          <div class="v mono" id="k_miss">‚Äî</div>
          <div class="s">Missing genotype fraction</div>
        </div>
        <div class="k">
          <div class="t">QDS: Œª‚Ççg‚Çé estimate</div>
          <div class="v mono" id="k_lambda">‚Äî</div>
          <div class="s">Coherence length proxy (from autocorr of heterozygosity)</div>
        </div>
        <div class="k">
          <div class="t">QDS: D_eff (effective independent)</div>
          <div class="v mono" id="k_deff">‚Äî</div>
          <div class="s">N_eff ~ N / (1 + 2Œ£œÅ‚Çñ‚Å∫)</div>
        </div>
      </div>

      <div style="margin-top:10px">
        <canvas id="plot" width="900" height="300"></canvas>
        <div class="small">Autocorrelation œÅ(k) vs lag k (index space). Œª‚Ççg‚Çé picked where œÅ(k) drops below 1/e.</div>
      </div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 8px 0;font-size:16px">Comparison output</h2>
      <div class="small">
        This is deliberately conservative: it treats your variant pattern as a <b>correlated field</b> and asks
        ‚Äúhow many <i>independent degrees of freedom</i> are you really carrying once redundancy is priced in?‚Äù
      </div>

      <hr/>

      <table>
        <thead>
          <tr><th>Metric</th><th>Mainstream</th><th>QDS-style</th></tr>
        </thead>
        <tbody id="cmp">
          <tr><td>D_raw</td><td class="mono">‚Äî</td><td class="mono">‚Äî</td></tr>
          <tr><td>Redundancy factor</td><td class="mono">‚Äî</td><td class="mono">‚Äî</td></tr>
          <tr><td>Œª‚Ççg‚Çé</td><td class="mono">‚Äî</td><td class="mono">‚Äî</td></tr>
          <tr><td>Coherence note</td><td>‚Äî</td><td>‚Äî</td></tr>
        </tbody>
      </table>

      <hr/>

      <h3 style="margin:0 0 6px 0;font-size:14px">Watchlist (if provided)</h3>
      <div id="watchOut" class="small">No watchlist yet.</div>

      <hr/>

      <h3 style="margin:0 0 6px 0;font-size:14px">Per-chromosome counts</h3>
      <div id="chromOut" class="small mono">‚Äî</div>

      <hr/>

      <div class="small">
        <b>Reality check:</b> this is a fast proxy, not a peer-reviewed PRS engine.
        It‚Äôs meant to quantify your point: <i>structure matters</i>. If you want the ‚Äúproper‚Äù version,
        you‚Äôd compute Œª‚Ççg‚Çé using full genotype LD, not just heterozygosity patterns.
        But this runs on a phone and still captures ‚Äúblockiness / redundancy.‚Äù
      </div>

      <div class="small" style="margin-top:8px">
        <span class="pill">Bonus</span>
        <span class="pill">Viking Confetti Index: <strong id="vci">‚Äî</strong></span>
      </div>
    </div>
  </div>
</div>

<script>
/* QDS Genomics Coherence Lab v1
   - Parses 23andMe raw txt
   - Main: D_raw, missing rate, heterozygosity
   - QDS: autocorrelation of heterozygosity => Œª_g proxy + N_eff => D_eff
   Phone-safe approach: sampling + lightweight stats.
*/

const el = (id)=>document.getElementById(id);

function fmtInt(x){
  if (!isFinite(x)) return "‚Äî";
  return Math.round(x).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
function fmtPct(x){
  if (!isFinite(x)) return "‚Äî";
  return (x*100).toFixed(2) + "%";
}
function fmtBp(x){
  if (!isFinite(x) || x<=0) return "‚Äî";
  if (x>=1e6) return (x/1e6).toFixed(2) + " Mb";
  if (x>=1e3) return (x/1e3).toFixed(1) + " kb";
  return Math.round(x) + " bp";
}

function drawPlot(rhos, lambdaIdx){
  const c = el("plot");
  const ctx = c.getContext("2d");
  const W = c.width, H = c.height;
  ctx.clearRect(0,0,W,H);

  // background grid
  ctx.globalAlpha = 1;
  ctx.strokeStyle = "#213045";
  ctx.lineWidth = 1;
  for (let i=0;i<=10;i++){
    const y = (H-20) - i*(H-40)/10;
    ctx.beginPath(); ctx.moveTo(40,y); ctx.lineTo(W-10,y); ctx.stroke();
  }
  for (let i=0;i<=10;i++){
    const x = 40 + i*(W-60)/10;
    ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,H-20); ctx.stroke();
  }

  // axes labels
  ctx.fillStyle = "#9fb0c3";
  ctx.font = "14px ui-monospace, Menlo, Consolas, monospace";
  ctx.fillText("œÅ(k)", 8, 22);
  ctx.fillText("lag k", W-90, H-6);

  if (!rhos || rhos.length < 2) return;

  const maxK = rhos.length-1;
  const minY = -0.2, maxY = 1.0;
  const X = (k)=> 40 + (k/maxK)*(W-60);
  const Y = (v)=> (H-20) - ((v-minY)/(maxY-minY))*(H-40);

  // curve
  ctx.strokeStyle = "#e7eef7";
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let k=1;k<=maxK;k++){
    const v = rhos[k];
    const x = X(k), y = Y(v);
    if (k===1) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // 1/e line
  const thr = 1/Math.E;
  ctx.strokeStyle = "#ffcc66";
  ctx.setLineDash([6,6]);
  ctx.beginPath(); ctx.moveTo(40, Y(thr)); ctx.lineTo(W-10, Y(thr)); ctx.stroke();
  ctx.setLineDash([]);

  // lambda marker
  if (lambdaIdx && lambdaIdx > 0 && lambdaIdx <= maxK){
    ctx.strokeStyle = "#90ee90";
    ctx.beginPath(); ctx.moveTo(X(lambdaIdx),10); ctx.lineTo(X(lambdaIdx),H-20); ctx.stroke();
    ctx.fillStyle = "#90ee90";
    ctx.fillText("Œª‚âà"+lambdaIdx, X(lambdaIdx)+6, 22);
  }
}

function parseWatchlist(txt){
  const s = (txt||"").trim();
  if (!s) return new Set();
  const items = s.split(/[\s,;]+/).map(x=>x.trim()).filter(Boolean);
  const set = new Set();
  for (const it of items){
    const t = it.toLowerCase().startsWith("rs") ? it.toLowerCase() : it;
    if (t.toLowerCase().startsWith("rs")) set.add(t);
  }
  return set;
}

function safeChrom(ch){
  // keep 1-22,X,Y,MT
  const c = (ch||"").toUpperCase();
  if (c==="X"||c==="Y"||c==="MT"||c==="M") return c==="M"?"MT":c;
  const n = parseInt(c,10);
  if (isFinite(n) && n>=1 && n<=22) return String(n);
  return null;
}

function autocorr01(arr, maxLag){
  // arr is 0/1 ints
  const n = arr.length;
  if (n < maxLag + 5) return null;

  let mean = 0;
  for (let i=0;i<n;i++) mean += arr[i];
  mean /= n;

  let var0 = 0;
  for (let i=0;i<n;i++){
    const d = arr[i]-mean;
    var0 += d*d;
  }
  var0 /= n;
  if (var0 <= 1e-12) return null;

  const r = new Array(maxLag+1).fill(0);
  r[0] = 1;

  for (let k=1;k<=maxLag;k++){
    let cov = 0;
    const m = n - k;
    for (let i=0;i<m;i++){
      cov += (arr[i]-mean)*(arr[i+k]-mean);
    }
    cov /= m;
    r[k] = cov/var0;
  }
  return r;
}

function combineAutocorr(perChrom, maxLag){
  // weighted by number of pairs (n-k)
  const r = new Array(maxLag+1).fill(0);
  const w = new Array(maxLag+1).fill(0);
  r[0]=1; w[0]=1;

  for (const chr of Object.keys(perChrom)){
    const a = perChrom[chr];
    const rr = autocorr01(a, maxLag);
    if (!rr) continue;
    const n = a.length;
    for (let k=1;k<=maxLag;k++){
      const pairs = Math.max(0, n-k);
      r[k] += rr[k]*pairs;
      w[k] += pairs;
    }
  }
  for (let k=1;k<=maxLag;k++){
    r[k] = (w[k]>0) ? (r[k]/w[k]) : 0;
  }
  return r;
}

function estimateLambdaIdx(rhos){
  const thr = 1/Math.E;
  for (let k=1;k<rhos.length;k++){
    if (rhos[k] <= thr) return k;
  }
  return rhos.length-1;
}

function estimateNeff(N, rhos){
  // Effective sample size using positive autocorrelation only
  // N_eff ~ N / (1 + 2 Œ£ rho_k^+)
  let s = 0;
  for (let k=1;k<rhos.length;k++){
    const rk = rhos[k];
    if (rk > 0) s += rk;
  }
  const denom = 1 + 2*s;
  return N / denom;
}

function status(msg){ el("status").textContent = msg; }

function tinyDemoText(){
  return `# 23andMe raw data demo (tiny)\n# rsid\tchromosome\tposition\tgenotype\nrs1\t1\t1000\tAA\nrs2\t1\t2000\tAG\nrs3\t1\t3000\tGG\nrs4\t1\t4000\tCC\nrs5\t1\t5000\tCT\nrs6\t1\t6000\tTT\nrs7\t2\t1000\tAA\nrs8\t2\t2000\t--\nrs9\t2\t3000\tAG\nrs10\t2\t4000\tGG\n`;
}

async function runOnText(text){
  const step = Math.max(1, Math.min(50, parseInt(el("step").value||"8",10)));
  const maxLag = Math.max(10, Math.min(300, parseInt(el("maxLag").value||"120",10)));
  const watch = parseWatchlist(el("watch").value);

  // Stats
  let total=0, called=0, missing=0;
  const hetByChr = {};  // sampled heterozygosity arrays
  const chromCounts = {}; // total called per chrom (not sampled)
  const chromMissing = {};
  const posPrev = {}; // for spacing estimate
  let spacingSum=0, spacingN=0;

  const watchHits = {}; // rsid -> {chr,pos,gt}
  const lines = text.split(/\r?\n/);

  status(`Parsing lines‚Ä¶ (${lines.length.toLocaleString()} lines)`);

  for (let idx=0; idx<lines.length; idx++){
    const line = lines[idx];
    if (!line || line[0]==="#") continue;
    const parts = line.split(/\t|,/);
    if (parts.length < 4) continue;

    const rsid = (parts[0]||"").trim().toLowerCase();
    const chr = safeChrom((parts[1]||"").trim());
    const pos = parseInt((parts[2]||"").trim(),10);
    const gt = (parts[3]||"").trim().toUpperCase();

    if (!chr || !isFinite(pos)) continue;
    total++;

    const isMissing = (gt==="--" || gt.length<2);
    if (isMissing){
      missing++;
      chromMissing[chr] = (chromMissing[chr]||0) + 1;
      continue;
    }
    called++;
    chromCounts[chr] = (chromCounts[chr]||0) + 1;

    // spacing estimate (per chromosome)
    if (posPrev[chr] != null){
      const d = pos - posPrev[chr];
      if (d>0 && d<5e6){ spacingSum += d; spacingN++; }
    }
    posPrev[chr] = pos;

    // watchlist capture
    if (watch.size && watch.has(rsid)){
      watchHits[rsid] = {chr, pos, gt};
    }

    // sampled heterozygosity field
    if ((chromCounts[chr] % step) === 0){
      if (!hetByChr[chr]) hetByChr[chr] = [];
      const het = (gt[0] !== gt[1]) ? 1 : 0;
      hetByChr[chr].push(het);
    }
  }

  const missRate = total>0 ? (missing/total) : NaN;
  const meanSpacing = spacingN>0 ? (spacingSum/spacingN) : NaN;

  // Build autocorrelation on sampled arrays
  const rhos = combineAutocorr(hetByChr, maxLag);
  const lambdaIdx = estimateLambdaIdx(rhos);

  // Convert Œª index to bp-ish using meanSpacing * step (rough)
  const lambdaBp = (isFinite(meanSpacing) ? (lambdaIdx * meanSpacing * step) : NaN);

  // N is sampled points total
  let Nsample = 0;
  for (const chr of Object.keys(hetByChr)) Nsample += hetByChr[chr].length;

  const Neff = (Nsample>0) ? estimateNeff(Nsample, rhos) : NaN;

  // Scale D_eff back to called SNP count (coarse)
  // Redundancy factor computed on the sampled set, applied as proxy to the full callset.
  const redundancy = (isFinite(Neff) && Neff>0) ? (Nsample/Neff) : NaN;
  const Deff = (isFinite(redundancy) && redundancy>0) ? (called/redundancy) : NaN;

  // UI updates
  el("k_raw").textContent = fmtInt(called);
  el("k_miss").textContent = fmtPct(missRate);
  el("k_lambda").textContent = isFinite(lambdaBp) ? (fmtBp(lambdaBp) + ` (k‚âà${lambdaIdx})`) : `k‚âà${lambdaIdx}`;
  el("k_deff").textContent = fmtInt(Deff);

  // Comparison table
  const cmp = el("cmp");
  const note = (!isFinite(redundancy)) ? "Not enough data to estimate coherence (try lower step / lower lag)." :
    (redundancy < 1.4 ? "Low redundancy ‚Üí variants behave more independently (less blockiness)." :
     redundancy < 2.2 ? "Moderate redundancy ‚Üí typical ‚Äòblocky‚Äô inheritance signal." :
     "High redundancy ‚Üí very blocky / correlated variation (strong tessellation proxy).");

  // Replace rows
  cmp.innerHTML = `
    <tr><td>D_raw</td><td class="mono">${fmtInt(called)}</td><td class="mono">${fmtInt(Deff)}</td></tr>
    <tr><td>Redundancy factor</td><td class="mono">‚Äî</td><td class="mono">${isFinite(redundancy)?redundancy.toFixed(2):"‚Äî"}√ó</td></tr>
    <tr><td>Œª‚Ççg‚Çé (proxy)</td><td class="mono">‚Äî</td><td class="mono">${isFinite(lambdaBp)?fmtBp(lambdaBp):"k‚âà"+lambdaIdx}</td></tr>
    <tr><td>Coherence note</td><td>Counts & PRS layers</td><td>${note}</td></tr>
  `;

  // Per chromosome print
  const keys = Object.keys(chromCounts).sort((a,b)=>{
    const na=parseInt(a,10), nb=parseInt(b,10);
    if (isFinite(na)&&isFinite(nb)) return na-nb;
    return a.localeCompare(b);
  });
  let out = "";
  for (const k of keys){
    out += `chr${k}: called=${chromCounts[k]||0} missing=${chromMissing[k]||0}\n`;
  }
  el("chromOut").textContent = out || "‚Äî";

  // Watchlist output
  if (!watch.size){
    el("watchOut").textContent = "No watchlist yet.";
  } else {
    const items = [...watch].sort();
    const rows = items.map(rs=>{
      const hit = watchHits[rs];
      if (!hit) return `<div class="mono">${rs}: <span class="warn">not found</span></div>`;
      return `<div class="mono">${rs}: ${hit.gt}  (chr${hit.chr}:${hit.pos})</div>`;
    }).join("");
    el("watchOut").innerHTML = rows || "‚Äî";
  }

  // Viking Confetti Index (for morale, not science)
  const vci = (isFinite(redundancy)? (redundancy * (1 - missRate) * 10) : NaN);
  el("vci").textContent = isFinite(vci) ? vci.toFixed(2) : "‚Äî";

  drawPlot(rhos, lambdaIdx);

  status(
`Done.
Lines parsed: ${fmtInt(total)} (data lines)
Called SNPs (D_raw): ${fmtInt(called)}
Missing: ${fmtInt(missing)} (${fmtPct(missRate)})
Sample kept: ${fmtInt(Nsample)} points (step=${step})
Œª‚Ççg‚Çé proxy: ${isFinite(lambdaBp)?fmtBp(lambdaBp):"k‚âà"+lambdaIdx}
Redundancy: ${isFinite(redundancy)?redundancy.toFixed(2)+"√ó":"‚Äî"}
D_eff: ${fmtInt(Deff)}
`
  );
}

el("demo").addEventListener("click", async ()=>{
  await runOnText(tinyDemoText());
});

el("run").addEventListener("click", async ()=>{
  const f = el("file").files && el("file").files[0];
  if (!f){
    status("No file selected. Pick your 23andMe raw .txt first (or hit Demo).");
    return;
  }
  status(`Loading file: ${f.name} (${Math.round(f.size/1024/1024)} MB)‚Ä¶`);

  const reader = new FileReader();
  reader.onload = async ()=> {
    try{
      await runOnText(String(reader.result||""));
    }catch(e){
      status("Error: " + (e && e.message ? e.message : String(e)));
    }
  };
  reader.onerror = ()=> status("File read error. Try re-downloading the raw data file.");
  reader.readAsText(f);
});
</script>
</body>
</html>
